# 第12章 类和动态内存分配

## 本章内容包括:

- 对类成员使用动态内存分配

- 隐式和显式复制构造函数

- 隐式和显式重载赋值运算符

- 在构造函数中使用new所必须完成的工作

- 使用静态类成员

- 将定位new运算符用于对象

- 使用指向对象的指针

- 实现队列抽象数据类型（ADT）

## 12.1 动态内存和类

**小结**：本节介绍了通过程序员自己提供**复制构造函数**和**赋值运算符**，使类能够正确管理类对象使用的内存。

### 12.1.1 复习示例和静态类成员

**小结**：本小节通过例子说明**编译器自动生成的成员函数**（如**复制构造函数**)会对程序造成影响，但是本小节没有给出具体的原因以及解决方法，而是留给后面的小节进行介绍。

结论：构造函数中new和析构函数中delete要成对出现。

**相关章节**：第16章

**Q**：请问下面的代码使用的是哪个构造函数？

```c++
StrngBad sailor = sports;
```

**A**：不是默认构造函数。记住，这种形式的初始化等效于下面的语句：

```c++
StrngBad sailor = StrngBad(sports); // constructor using sports
```

​	**说明**：因为`sports`的类型为`StrngBad`，因此相应的构造函数原型应该如下。当使用一个对象初始化另一个对象时，编译器将自动生成上述构造函数（称为复制构造函数，因为它创建对象的一个副本）。

```c++
StringBad(const StringBad &);
```

### 12.1.2 特殊成员函数

**Q**：在**程序员没有提供**的情况下，**C++自动提供**哪些成员函数？

**A**：

1）默认构造函数、默认析构函数、复制构造函数、赋值运算符、地址运算符；

2）C++11提供了另外两个特殊成员函数：移动构造函数（move constructor）和移动赋值运算符（move assignment operator），这将在第18章讨论。

**1.默认构造函数**

**小结**：默认构造函数用于对象的初始化。一个类必定有唯一的构造函数，如果程序员不提供，则系统会自动提供。

**关于默认构造函数的3点声明**：

1）如果程序员没有提供任何构造函数，则编译器将提供以下默认构造函数：

```c++
Klunk::Klunk(){}
```

2）如果程序员定义了构造函数，C++ 将不会定义默认构造函数，程序员也要提供默认构造函数：

​	**方法1**：显式默认构造函数：

```c++
Klunk::Klunk()	// explicit default constructor
{
    klunk_ct = 0;
}
```

​	**方法2**：带参数的构造函数也可以是默认构造函数，只要所有参数都有默认值。例如，Klunk类可以包含下述内联构造函数：

```c++
Klunk(int n = 0){klunk_ct = n};
```

3）一个类只能有一个默认构造函数，不然会造成**二义性**：

```c++
Klunk() {klunk_ct = n;}				 // constructor #1
Klunk(int n = 0) {klunk_ct = n;}	// ambigous constructor #2

Klunk kar(10);						// clearly matches Klunt (int n)
Klunk(int n = 0) {klunk_ct = n;}	// could match either constructor
```

​	**说明**：第二个声明既与构造函数#1（没有参数匹配），也与构造函数#2（使用默认构造函数参数0）匹配。这将导致编译器发出一条错误消息。

**2.复制构造函数**

**Q**：为什么要有“复制构造函数”的概念？

**A**：当新建一个对象并将其初始化为同类现有对象，或者当程序需要对象副本。这些场景是默认构造函数无法解决的，因而需要有复制构造函数的概念。

**Q**：复制构造函数的**功能**？

**A**：复制构造函数用于将一个对象复制到新创建的对象中。

**Q**：复制构造函数的**原型**？

**A**：

```c++
Class_name(const Class_name &);
```

​		**说明**：它接受一个指向类对象的常量引用作为参数。

> 对于复制构造函数,需要知道两点：何时调用和有何功能。后文将做介绍。

**3.何时调用复制构造函数**

**Q**：何时调用复制构造函数？

**A**：

1）**新建一个对象并将其初始化为同类现有对象时**，复制构造函数都将被调用：

```c++
StringBad ditto(motto);
StringBad metoo = motto;
StringBad also = StringBad(motto);
StringBad * pStringBad = new StringBad(motto);
```

2）**每当程序生成了对象副本时，编译器都将使用复制构造函数**：具体地说，**当函数按值传递对象**（如程序清单12.3中的callme2()）、**函数返回对象**、**编译器生成临时对象**时都会使用复制构造函数。

**结论**：由于按值传递将调用复制构造函数，因此应该按引用传递对象。这样可以节省调用构造函数的时间以及存储新对象的空间。

**4.默认的复制构造函数的功能**

**Q**：默认的复制构造函数实现的是什么功能？

**A**：默认的复制构造函数逐个复制非静态成员（成员复制也称为**浅复制**），复制的是成员的值。

### 12.1.3 回到Stringbad：复制构造函数的哪里出了问题

**提示**：如果类中静态成员变量如本例的使用情况，则其值将在新对象创建时发生变化，则应该提供一个显式复制构造函数来处理计数问题。

浅复制有可能造成重复释放同一块内存导致不确定的、可能有害的后果。

**1.定义一个显式复制构造函数以解决问题**

**警告**：如果类中包含了使用new初始化的指针成员，应当定义一个复制构造函数，以复制指向的数据而不是指针，这被称为深度复制。复制的另一种形式（成员复制或浅复制）只是复制指针值。浅复制仅浅浅地复制指针信息，而不会深入“挖掘”以复制指针引用的结构。

**程序清单**：

**程序清单12.2 strngbad.cpp**

**Q**：如何初始化静态成员？

**A**：

```c++
int StringBad::num_strings = 0;
```

​	**说明**：

​	1）不能在类声明中初始化静态成员函数，这是因为声明描述了如何分配内存，但并不分配内存；

​	2）对于静态类成员，可以在类声明之外使用单独的语句进行初始化，这是因为静态类成员是单独存储的，而不是对象的组成部分；

​	3）请注意，初始化语句指出了类型，并使用了作用域运算符，但没有使用关键字`static`；

​	4）静态数据成员要初始化要在方法文件中，而不是在类声明文件中进行的，这是因为类声明位于头文件中，程序可能将头文件包括在其他几个文件中。如果在头文件中进行初始化，将出现多个初始化语句副本，从而引发错误；

​	5）对于不能在类声明中初始化静态数据成员的一种例外情况（见第10章）是，静态数据成员为整型或枚举型`const`。

**警告**：在构造函数中使用`new`来分配内存时，必须在相应的析构函数中使用`delete`来释放内存。如果使用`new[]`（包括中括号），则应使用`delete[]`（包含中括号）来释放内存。

**程序清单12.3 vegnews.cpp**

**说明**:该程序将对象声明在一个内部代码块中,因为析构函数将在定义对象的代码块执行完毕时调用。如果不这么做，析构函数将在`main()`函数执行完毕时调用，导致您无法在执行窗口关闭前看到析构函数显示的消息。

### 12.1.4 Stringbad的其他问题：赋值运算符

**Q**：如何理解**类对象赋值**？

**A**：ANSI C允许结构赋值，而C++允许类对象赋值，这是通过**自动为类重载赋值运算符**实现的。这种运算符的**原型**如下：

```c++
Class_name & Class_name::operator=(const Class_name &);

StringBad & StringBad::operator=(const StringBad &);
```

**1.赋值运算符的功能以及何时使用它**

**2.赋值的问题出在哪里**

**小结**：本小节介绍了程序清单12.3中赋值运算符重载的浅复制会导致程序运行结果异常，原因是由于重复释放已释放的内存。

**3.解决赋值的问题**

**Q**：如何提供赋值运算符（进行深复制）？

**A**：

1）由于目标对象可能引用了以前分配的数据，所以函数应使用`delete[]`来释放这些数据；

2）函数应当避免将对象赋给自身：否则，给对象重新赋值前，释放内存操作可能删除对象的内容；

3）函数返回一个指向调用对象的引用。

## 12.2 改进后的新String类

### 12.2.1 修订后的默认构造函数

**相关章节**：`new[]`和`delete[]`。

### 12.2.2 比较成员函数

