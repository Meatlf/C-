# chapter09-内存模型和名称空间

## 9.3 名称空间

**相关章节**：本章相关章节为第4章的模板类`vector`和`array`、第10章的Stack实例、第12章的Queue实例、第16章的C++标准库模板库（STL)提供了几个功能强大而灵活的容器模板实现。

**Q**:回忆一下第10章中是如何实现Stack类支持多种类型的数据的？如何评价其做法？

**A**:第10章中通过使用`typedef`来处理Stack类要支持多种数据类型这一需求。该做法有如下2个缺点：

1）每次修改类型时都需要编辑头文件;

2）不能让`typedef`同时代表2种不同的类型。PS:由于使用`typedef`会造成这2个问题，因而需要引入`类模板`来解决这一问题。

**Q**：**函数模板**和**类模板**有什么**共性**？

**A**：

1）**参数类型不一样**，**结构都完全一样**；

2）正是因为1），使得代码具有**重用性**。

### 14.4.1 定义类模板

**Q**:关于类模板，有哪几点需要强调的？

**A**:

1）类声明的前面要加上`template<typename T>`;

2）方法实现的前面要加上`template<typename T>`;

3）类模板的声明和定义放在一个文件中，因为类模板不是函数，它们不能单独编译。模板必须与特定的模板实例化请求一起使用。

**Q**：模板类的代码开头是什么？

**A**：本节主要讲了如何声明和定义类模板。所有讲解都是为了理解程序清单14.13服务的。

```c++
// 方法1：辨识度高，优选使用
template<typename T> class Ref{
private:
public:
}

// 方法2：辨识度低，不推荐使用
template<class T> class Ref{
private:
public:
}
```

**注意**:对于类模板，必须显式地提供所需的类型，函数模板可以无需提供所需类型，因为编译器可以根据函数参数类型来确定要生成哪种函数。



