# 第11章 使用类

## 本章内容包括:

- 运算符重载
- 友元函数
- 重载<<运算符,以便于用于输出
- 状态成员
- 使用rand()生成随机值
- 类的自动转换和强制类型转换
- 类转换函数

**相关章节**：第10章。

Q：如何更好的掌握C++的新特性？

A：如果函数使用常规参数而不是引用参数，将发生什么情况呢？如果忽略了析构函数，又将发生什么情况呢？

**学习方法**：

1）不要害怕犯错误，因为在解决问题的过程中学到的知识，比生搬硬套而不犯错误要多得多（然而，不要认为所有的错误都会让人增长见识）；

2）学习本章知识最好的最好方法是，在我们自己开发的C++程序中使用其中的新特性。对这些新特性有了充分的认识后，就可以添加其他C++特性了。

3）C++创始人Bjarne Stroustrup在一次C++专业程序员大会上所建议的：“轻松地使用这种语言。不要觉得必须使用所有的特性，不要在第一次学习时试图使用所有的特性。“

##  11.1 运算符重载

**小结**：本节主要介绍了运算符重载的技术背景、格式。

**相关章节**：第8章的函数重载和函数多态

**Q**：如何理解运算符重载？

**A**：运算符重载是一种形式的C++**多态**。

**Q**：运算符重载函数的格式？

**A**：

```c++
operator op(argument-list)
```



##  11.2 计算时间：一个运算重载示例

**程序清单**：程序清单11.1 mytime0.h、11.2 mytime0.cpp、11.3 usetime0.cpp构成了关于时间加法的类（分别对应声明、定义、使用），这里的时间加法实现是用`Time::Sum()`成员函数完成的，而这将为在11.2.1小节中用加法运算符替代，这里用`Time::Sum()`只是起到抛砖引玉的作用。

**警示**：分析程序清单11.1和11.2，要理解不可以将`Time::Sum()`成员函数的返回值设置为引用。原因是不要返回指向局部变量或临时对象的引用。函数执行完毕后，局部变量和临时对象将消失，引用将指向不存在的数据。

### 11.2.1 添加加法运算符

**程序清单**：

1）程序清单11.4 mytime1.h、11.5 mytime1.cpp说明了如何声明和定义”运算符成员函数“。具体而言，程序清单11.4和11.5分别是对11.2和11.5的改进，将`Time::Sum()`的名称改为`Time::operate+()`即可。

2）程序清单11.6 usetime1.cpp说明了使用加法运算符的两种方法，具体如下：

```c++
total = coding.operator+(fixing);	// 方法1：与一般成员函数一致的使用方法
total = coding + fixing;			// 方法2：运算符表示法
```

**提示**：如果t1、t2、t3都是Time对象，以下运算是合法的，需要理解原因，书本中也详细说明了。

```c++
t4 = t1 + t2 + t3;
```

### 11.2.2 重载限制

**小结**：多数C++运算符都可以重载，可以重载的运算符见表11.1。这就说明有些运算符是不可以重载的。

### 11.2.3 其他重载运算符

**程序清单**：程序清单11.7 mytime2.h、11.8 mytime2.cpp、11.9 usetime2.cpp说明了创建`operator-()`和`operator*()`的方法，其实都和之前的`operator+()`一样的。

## 11.3 友元

**Q**：友元的分类？

**A**：友元分为3种，分别为友元函数、友元类、友元成员函数。

**Q**：为何**需要**友元？

**A**：在为类重载二元运算符时（带两个参数的运算符）常常需要友元：

```c++
A = B * 2.75;
A = B.operator*(2.75);	// 与上一行代码等价

A = 2.75 * B;			// cannot correspond to a member function
```

​	**说明**：左侧的操作数应是调用对象。

Q：如何解决`A = 2.75 * B`非法的问题？

A：使用非成员函数（记住，大多数运算符都可以通过成员或非成员函数来重载）。非成员函数不是由对象调用的，它使用的所有值（包括对象）都是显式参数。该函数的原型如下：

```c++
Time operator*(double m, const Time & t);
```

​		**说明**：常规的非成员函数不能直接访问类的私有数据。然而是可以用特殊的非成员函数来解决之一问题，这种函数被称为友元函数。

### 11.3.1 创建友元

**小结**：本小节介绍了如何声明和定义友元函数、友元和类的关系。

**Q**：如何声明友元？

**A**：将友元放在类声明中，并在原型声明前加上关键字`friend`：

```c++
friend Time operator*(double m, const Time & t);	// goes in class declaration
```

​	**说明**：

​	1）虽然`operator*()`函数是在类声明中声明的,但它不是成员函数,因此不能使用成员运算符来调用;

​	2）虽然`operator*()`函数不是成员函数，但它与成员函数的访问权限相同。

**Q**：如何定义友元？

**A**：因为友元函数不是成员函数，所有不要使用`Time::`限定符。另外，不要在定义中使用关键字`friend`，定义应该如下(书本中的代码段中的`mult`应为`m`：

```c++
Time operator*(double m, const Time & t)	// friend not used in definition
{
    Time result;
    long totalminutes = t.hours * m * 60 + t.minutes * m;
    result.hours = totalminutes / 60;
    result.minutes = totalminutes % 60;
    return result;
}
```

**友元是否有悖于OOP**

**说明**：类方法和友元只是表达类接口的两种不同机制，因而友元不违反OOP。

### 11.3.2 常用的友元：重载<<运算符

**小结**：本小节介绍了重载<<运算符的技术背景、定义、使用。

**程序清单**：程序清单11.10 mytime3.h、11.11 mytime3.cpp、11.12 usetime3.cpp共同构成了重载<<运算符的helloworld。

**相关章节**：第6、8、13章。

**Q**：重载<<运算符的**技术背景**是什么？

**A**：使得<<运算符能与`cout`一起来显示对象的内容。

**提示**：一般来说，要重载<<运算符来显示c_name的对象,可使用一个友元函数,其定义如下:

```c++
ostream & operator<<(ostream & os, const c_name & obj)
{
	os << ...;	// display object contents
	return os;
}
```

## 11.4 重载运算符：作为成员函数还是非成员函数

**注意**：非成员函数实现运算符重载所需的参数数目与运算符使用的操作数目相同；而成员函数实现运算符重载的参数数目少一个，因为其中的一个操作数是被隐式地传递的调用对象。

## 11.5 再谈重载：一个矢量类

## 11.6 类的自动转换和强制类型转换

**相关章节**：第3章中的类型转换和磅转换为英石的程序。